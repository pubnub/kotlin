/*
 * This source file was generated by the Gradle 'init' task
 */
package com.pubnub.migration

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.Context
import com.github.ajalt.clikt.core.main
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.options.default
import com.github.ajalt.clikt.parameters.options.flag
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.options.split
import com.github.ajalt.clikt.parameters.types.path
import java.io.InputStream

class Migration(private val replacements: List<Pair<Regex, String>>) : CliktCommand("migration_utils") {
    val dryRun by option(help = "Perform a dry run (without changing any files)").flag()
    val noBackups by option(help = "Do not save backups of changed files as '<filename>.bck'").flag()
    val directory by argument(name = "project directory").path(mustExist = true, canBeDir = true, canBeFile = true)
    val extensions by option(help = "Provide a list of file extensions to consider. Default: java, kt").split(",").default(
        listOf("kt", "java")
    )

    override fun help(context: Context): String {
        return "This command will scan all files ending with extensions specified in `--extensions=kt,java`" +
                " in <project directory>, and replace package names of classes that have been moved to " +
                "com.pubnub.api.java.* in PubNub Java SDK v10.\n\n" +
                "Perform a --dry-run to print a list of files that will be changed.\n\n" +
                "It is the responsibility of the user to back up any files before running this tool."
    }

    override val printHelpOnEmptyArgs: Boolean = true

    override fun run() {
        directory.toFile().walk().forEach { file ->
            if (file.extension.lowercase() !in this.extensions) {
                return@forEach
            }
            val newFileContent = file.useLines { lines ->
                replaceLines(lines, replacements)
            }
            if (newFileContent != null) {
                if (!dryRun) {
                    if (!noBackups) {
                        file.copyTo(file.resolveSibling(file.name + ".bck"), overwrite = false)
                    }
                    file.writeText(newFileContent)
                }
                println(file.path)
            }
        }
    }

    companion object {
        fun replaceLines(
            lines: Sequence<String>,
            replacements: List<Pair<Regex, String>>,
        ): String? {
            var fileChanged = false
            val newFileContent = lines.fold(StringBuilder()) { acc: StringBuilder, line: String ->
                val replacedLine = replaceLine(line, replacements)
                if (replacedLine != line) {
                    fileChanged = true
                }
                acc.appendLine(replacedLine)
            }
            return if (fileChanged) {
                newFileContent.toString()
            } else {
                null
            }
        }

        fun replaceLine(
            line: String,
            replacements: List<Pair<Regex, String>>,
        ): String {
            return replacements.fold(line) { lineUnderReplacement, replacement ->
                lineUnderReplacement
                    .replace(replacement.first, replacement.second)
            }
        }

        fun loadReplacementsFile(inputStream: InputStream): List<Pair<Regex, String>> =
            inputStream
                .bufferedReader()
                .readLines()
                .map {
                    val split = it.split(':')
                    require(split.size == 2)
                    Regex("(?u)" + split[0].replace(".", "\\.") + "(?!\\p{Alnum})") to split[1]
                }
    }
}

fun main(args: Array<String>) = Migration(Migration.loadReplacementsFile(Migration::class.java.getResourceAsStream("/replacements.txt")!!)).main(args)
