/*
 * This source file was generated by the Gradle 'init' task
 */
package com.pubnub.migration

import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.Context
import com.github.ajalt.clikt.core.main
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.options.flag
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.types.path

class Migration(private val replacements: List<Pair<String, String>>) : CliktCommand("migration_utils") {
    val dryRun by option(help = "Perform a dry run (without changing any files)").flag()
    val noBackups by option(help = "Do not save backups of changed files as '<filename>.bck'").flag()
    val directory by argument(name = "project directory").path(mustExist = true, canBeDir = true, canBeFile = false)

    val supportedExtensions = setOf("java", "kt")

    override fun help(context: Context): String {
        return "This command will scan all files ending with ${supportedExtensions.map { "'.$it'" }.joinToString(", ")}" +
                " in <project directory>, and replace package names of classes that have been moved to " +
                "com.pubnub.api.java.* in PubNub Java SDK v10.\n\n" +
                "Perform a --dry-run to print a list of files that will be changed.\n\n" +
                "It is the responsibility of the user to back up any files before running this tool."
    }

    override val printHelpOnEmptyArgs: Boolean = true

    override fun run() {
        directory.toFile().walk().forEach { file ->
            if (file.extension.lowercase() !in supportedExtensions) {
                return@forEach
            }
            val newFileContent = file.useLines { lines ->
                replaceLines(lines, replacements)
            }
            if (newFileContent != null) {
                if (!dryRun) {
                    if (!noBackups) {
                        file.copyTo(file.resolveSibling(file.name + ".bck"), overwrite = false)
                    }
                    file.writeText(newFileContent)
                }
                println(file.path)
            }
        }
    }

    companion object {
        fun replaceLines(
            lines: Sequence<String>,
            replacements: List<Pair<String, String>>,
        ): String? {
            var fileChanged = false
            val newFileContent = lines.fold(StringBuilder()) { acc: StringBuilder, line: String ->
                val replacedLine = replaceLine(line, replacements)
                if (replacedLine != line) {
                    fileChanged = true
                }
                acc.appendLine(replacedLine)
            }
            return if (fileChanged) {
                newFileContent.toString()
            } else {
                null
            }
        }

        fun replaceLine(
            line: String,
            replacements: List<Pair<String, String>>,
        ): String {
            return replacements.fold(line) { lineUnderReplacement, replacement ->
                lineUnderReplacement
                    .replace(replacement.first, replacement.second)
            }
        }

        fun loadReplacementsFile(): List<Pair<String, String>> =
            this::class.java.getResourceAsStream("/replacements.txt")!!
                .bufferedReader()
                .readLines()
                .map {
                    val split = it.split(':')
                    require(split.size == 2)
                    split[0] to split[1]
                }
    }
}

fun main(args: Array<String>) = Migration(Migration.loadReplacementsFile()).main(args)
